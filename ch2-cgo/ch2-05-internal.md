# 2.5 Internal mechanism

For those who have just come into contact with CGO, many of the features of CGO are similar to magic. The CGO feature mainly assists in outputting the bridge code between Go and C through a command line tool called cgo. In this section we try to analyze the flow of the Go language and C language functions directly from each other from the generated code.

## 2.5.1 Intermediate files generated by CGO

To understand the underlying secrets of CGO technology, you first need to understand which intermediate files CGO generates. We can add a `-work` output to the directory where the intermediate build file is located when building a cgo package and keep the intermediate file when the build is complete. If it is a simple cgo code, we can also directly view the generated intermediate file by manually calling the `go tool cgo` command.

In a Go source file, if the `import "C"` directive appears, it means that the cgo command will be called to generate the corresponding intermediate file. The following figure is a simple diagram of the intermediate file generated by cgo:

![](../images/ch2-4-cgo-generated-files.dot.png)

*Figure 2-4 intermediate files generated by cgo*


There are 4 Go files in the package, where the file starting with nocgo does not have the `import "C"` command, and the other 2 files contain the cgo code. The cgo command creates two intermediate files for each Go file that contains cgo code. For example, main.go creates two intermediate files, main.cgo1.go and main.cgo2.c. A `_cgo_gotypes.go` Go file is created for the entire package, which contains some help code for the Go language. In addition, a `_cgo_export.h` and `_cgo_export.c` files are created, corresponding to the types and functions exported by the Go language to the C language.

## 2.5.2 Go calls C function

Go calls C functions is the most common application scenario of CGO. We will start with the simplest example to analyze the detailed flow of Go calls C functions.

The specific code is as follows (main.go):

```go
Package main

//int sum(int a, int b) { return a+b; }
Import "C"

Func main() {
Println(C.sum(1, 1))
}
```

There is no error in building and running the example first. Then generate an intermediate file in the _obj directory via the cgo command line tool:

```
$ go tool cgo main.go
```

View the _obj directory to generate intermediate files:

```
$ ls _obj | awk '{print $NF}'
_cgo_.o
_cgo_export.c
_cgo_export.h
_cgo_flags
_cgo_gotypes.go
_cgo_main.c
Main.cgo1.go
Main.cgo2.c
```

The `_cgo_.o`, `_cgo_flags`, and `_cgo_main.c` files have no direct logical association with our code and can be ignored for now.

Let's first look at the `main.cgo1.go` file, which is the Go code after the main.go file expands the virtual C package related functions and variables:

```go
Package main

//int sum(int a, int b) { return a+b; }
Import _ "unsafe"

Func main() {
Println((_Cfunc_sum)(1, 1))
}
```

The `C.sum(1, 1)` function call is replaced with `(_Cfunc_sum)(1, 1)`. Each function of the form `C.xxx` is replaced with a pure Go function of the `_Cfunc_xxx` format, where the prefix `_Cfunc_` indicates that this is a C function corresponding to a private Go bridge function.

The `_Cfunc_sum` function is defined in the `_cgo_gotypes.go` file generated by cgo:

```go
//go:cgo_unsafe_args
Func _Cfunc_sum(p0 _Ctype_int, p1 _Ctype_int) (r1 _Ctype_int) {
_cgo_runtime_cgocall(_cgo_506f45f9fa85_Cfunc_sum, uintptr(unsafe.Pointer(&p0)))
If _Cgo_always_false {
_Cgo_use(p0)
_Cgo_use(p1)
}
Return
}
```

The `_Cfunc_sum` function's parameters and the return value `_Ctype_int` type correspond to the `C.int` type. The named rules are similar to `_Cfunc_xxx`. Different prefixes are used to distinguish between functions and types.

Where `_cgo_runtime_cgocall` corresponds to the `runtime.cgocall` function, and the function declaration is as follows:

```go
Func runtime.cgocall(fn, arg unsafe.Pointer) int32
```

The first parameter is the address of the C language function, and the second parameter is the address of the parameter structure corresponding to the C language function.

In this example, the passed C language function `_cgo_506f45f9fa85_Cfunc_sum` is also an intermediate function generated by cgo. The function is defined in `main.cgo2.c`:

```c
Void _cgo_506f45f9fa85_Cfunc_sum(void *v) {
Struct {
Int p0;
Int p1;
Int r;
Char __pad12[4];
} __attribute__((__packed__)) *a = v;
Char *stktop = _cgo_topofstack();
__typeof__(a->r) r;
_cgo_tsan_acquire();
r = sum(a->p0, a->p1);
_cgo_tsan_release();
a = (void*)((char*)a + (_cgo_topofstack() - stktop));
A->r = r;
}
```

This function parameter has only one pointer to the void paradigm, and the function has no return value. The function parameters and return values ​​of the real sum function are implemented by a unique parameter pointer class.

The structure of the pointer to the `_cgo_506f45f9fa85_Cfunc_sum` function points to:

```c
Struct {
Int p0;
Int p1;
Int r;
Char __pad12[4];
} __attribute__((__packed__)) *a = v;
```

The p0 member corresponds to the first parameter of sum, the p1 member corresponds to the second parameter of sum, and the r member, `__pad12` is used to fill the structure to ensure alignment of the integral multiple of the CPU machine word.

Then, after obtaining the calling parameter from the structure pointed to by the parameter, the real C language version sum function is called, and the return value is kept to the member corresponding to the return value in the structure body.

Because Go and C have different memory models and function call specifications. The code associated with the `_cgo_topofstack` function is used to restore the call stack after a C function call. `_cgo_tsan_acquire` and `_cgo_tsan_release` are functions for scanning CGO related functions, and are related to the pointers of CGO related functions.


The entire call flow diagram of `C.sum` is as follows:

![](../images/ch2-5-call-c-sum-v1.uml.png)

*Figure 2-5 Calling C function*

The `runtime.cgocall` function is the key to implementing cross-border calls from Go to C. More detailed details can be found in the https://golang.org/src/cmd/cgo/doc.go internal code comments and the implementation of the `runtime.cgocall` function.

## 2.5.3 C calls the Go function

After a brief analysis of the flow of Go calls C functions, we now analyze the flow of C's reverse call to the Go function. Similarly, we now construct a Go function in the Go language, the file name is also `main.go`:

```
Package main

//int sum(int a, int b);
Import "C"

//export sum
Func sum(a, b C.int) C.int {
Return a + b
}

Func main() {}
```

The syntax details of CGO are not described here. In order to use the sum function in C, we need to compile the Go code into a C static library:

```
$ go build -buildmode=c-archive -o sum.a main.go
```

If there are no errors, the above compile command will generate a `sum.a` static library and a `sum.h` header file. The `sum.h` header file will contain the declaration of the sum function, and the static library will contain the implementation of the sum function.

To analyze the call flow of the generated C language version of the sum function, you also need to analyze the intermediate files generated by cgo:

```
$ go tool cgo main.go
```

The _obj directory still generates similar intermediate files. For the sake of convenience, we deliberately ignored a few unrelated files:

```
$ ls _obj | awk '{print $NF}'
_cgo_export.c
_cgo_export.h
_cgo_gotypes.go
Main.cgo1.go
Main.cgo2.c
```

The content of the `_cgo_export.h` file is the same file as the `sum.h` header file generated when the C static library is generated. It also contains the declaration of the sum function.

Since the C language is the main caller, we need to start with the implementation of the C language version of the sum function. The C language version of the sum function is in the generated `_cgo_export.c` file (this file contains the C language function implementation corresponding to the Go language export function):

```c
Int sum(int p0, int p1)
{
__SIZE_TYPE__ _cgo_ctxt = _cgo_wait_runtime_init_done();
Struct {
Int p0;
Int p1;
Int r0;
Char __pad0[4];
} __attribute__((__packed__)) a;
A.p0 = p0;
A.p1 = p1;
_cgo_tsan_release();
Crosscall2(_cgoexp_8313eaf44386_sum, &a, 16, _cgo_ctxt);
_cgo_tsan_acquire();
_cgo_release_context(_cgo_ctxt);
Return a.r0;
}
```

The content of the sum function is similar to the previous one. The parameters and return values ​​of the sum function are packed into a structure, and then the structure is passed to the `_cgoexp_8313eaf44386_sum` function by the `runtime/cgo.crosscall2` function.

The `runtime/cgo.crosscall2` function is implemented in assembly language, and its corresponding function declaration is as follows:

```go
Func runtime/cgo.crosscall2(
Fn func(a unsafe.Pointer, n int32, ctxt uintptr),
a unsafe.Pointer, n int32,
Ctxt uintptr,
)
```

The key is fn and a, fn is a pointer to the intermediate proxy function, and a is a pointer to the structure corresponding to the calling argument and the return value.

The middle `_cgoexp_8313eaf44386_sum` proxy function is in the `_cgo_gotypes.go` file:

```go
Func _cgoexp_8313eaf44386_sum(a unsafe.Pointer, n int32, ctxt uintptr) {
Fn := _cgoexpwrap_8313eaf44386_sum
_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n), ctxt);
}

Func _cgoexpwrap_8313eaf44386_sum(p0 _Ctype_int, p1 _Ctype_int) (r0 _Ctype_int) {
Return sum(p0, p1)
}```

Internally, the wrapper function `_cgoexpwrap_8313eaf44386_sum` is used as a function pointer, and then the callback of the C language to the Go function is completed by the `_cgo_runtime_cgocallback` function.


The `_cgo_runtime_cgocallback` function corresponds to the `runtime.cgocallback` function. The types of functions are as follows:

```go
Func runtime.cgocallback(fn, frame unsafe.Pointer, framesize, ctxt uintptr)
```

The parameters are the function pointer, the function parameter and the return value corresponding to the pointer of the structure, the function call frame size and the context parameter.

The entire call flow chart is as follows:

![](../images/ch2-6-call-c-sum-v2.uml.png)

*Figure 2-6 Calling the exported Go function*

The `runtime.cgocallback` function is the key to implementing cross-border calls from C to Go. More detailed details can be found in the implementation of related functions.