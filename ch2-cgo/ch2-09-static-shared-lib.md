# 2.9 Static and dynamic libraries

CGO generally has three forms when using C/C++ resources: direct source code; link static library; link dynamic library. Direct use of the source code is to include the C code in the comment section before the `import "C"`, or to include the C/C++ source file in the current package. The way to link static and dynamic libraries is similar, by specifying the library link to be linked in the LDFLAGS option. In this section we focus on how to use static libraries and dynamic libraries in CGO.

## 2.9.1 Using C Static Library

If the C/C++ resources introduced in CGO have code and the code size is small, direct use of source code is the most ideal way, but many times we don't have source code, or the process of building from C/C++ source code is very complicated. This time using a C static library is also a good choice. Because static libraries are statically linked, the final target program does not generate additional runtime dependencies, nor does it have dynamic library-specific cross- runtime resource management errors. However, static libraries have certain requirements for the link phase: static libraries generally contain all the code, which will have a large number of symbols. If there is a symbol conflict between different static libraries, the link will fail.

We first construct a simple static library with pure C language. The static library we are constructing is called number. There is only one number_add_mod function in the library to represent the modulo addition in number theory. The files of the number library are all in the number directory.

The `number/number.h` header file has only a pure C language style function declaration:

```c
Int number_add_mod(int a, int b, int mod);
```

`number/number.c` corresponds to the implementation of the function:

```c
#include "number.h"

Int number_add_mod(int a, int b, int mod) {
Return (a+b)%mod;
}
```

Because CGO uses GCC commands to compile and link C and Go bridged code. Therefore the static library must also be in a GCC compatible format.

A static library called libnumber.a can be generated by the following command:

```
$ cd ./number
$ gcc -c -o number.o number.c
$ ar rcs libnumber.a number.o
```

After generating the libnumber.a static library, we can use it in CGO.

Create the main.go file as follows:

```go
Package main

//#cgo CFLAGS: -I./number
//#cgo LDFLAGS: -L${SRCDIR}/number -lnumber
//
//#include "number.h"
Import "C"
Import "fmt"

Func main() {
fmt.Println(C.number_add_mod(10, 5, 12))
}
```

There are two #cgo commands, which are compile and link parameters. CFLAGS adds the directory where the corresponding header file of the number library is located to the header file retrieval path by `-I./number`. LDFLAGS adds the directory where the number static library is compiled to the link library search path by `-L${SRCDIR}/number`, and `-lnumber` indicates the link libnumber.a static library. It should be noted that the search path in the link part cannot use the relative path (limited by the C/C++ code linker), we must expand the current directory path corresponding to the source file to the cgo-specific `${SRCDIR}` variable. Absolute path (so absolute paths cannot have blank symbols in windows platforms).

Because we have all the code for the number library, we can use the get generate tool to generate static libraries, or use Makefiles to build static libraries. Therefore, when publishing the CGO source package, we do not need to build the C static library in advance.

Because there is more than one static library build step, this Go package that uses a custom static library and already contains all the code of the static library cannot be installed directly with go get. However, we can still download via go get, then use go generate to trigger the static library build, and finally go install to complete the installation.

In order to support the go get command to download and install directly, our C language `#include` syntax can link the source file of the number library to the current package.

Create the `z_link_number_c.c` file as follows:

```c
#include "./number/number.c"
```

Then when executing a command such as go get or go build, CGO automatically builds the code corresponding to the number library. This technique converts static libraries into source code references without changing the organization structure of the static library source code. This CGO package is perfect.

If you are using a third-party static library, we need to download and install the static library to the appropriate location. Then specify the location of the header files and libraries via CFLAGS and LDFLAGS in the #cgo command. For different operating systems or even different versions of the same operating system, the installation paths of these libraries may be different, so how to specify these possible changes in the code?

In the Linux environment, there is a pkg-config command that can query the compile and link parameters when using a static or dynamic library. We can use the pkg-config command directly in the #cgo command to generate compilation and linking parameters. You can also customize the pkg-config command with the PKG_CONFIG environment variable. Because different operating systems support the pkg-config command differently, it is difficult to be compatible with the build parameters of different operating systems. However, for specific systems such as Linux, the pkg-config command does simplify the management of build parameters. The details of the use of pkg-config are not extended here, so you can refer to the relevant documentation.

## 2.9.2 Using C Dynamic Library

The original intention of dynamic libraries is that for the same library, multiple processes can share the same one to save memory and disk resources. But in today's disk and memory has been the price of cabbage, these two roles have become insignificant, then what other value of the dynamic library is there? From the perspective of library development, dynamic libraries can isolate the relationships between different dynamic libraries and reduce the risk of symbol conflicts when linking. And for platforms such as windows, dynamic libraries are the only viable way to span different compiler platforms for VC and GCC.

For CGO, the use of dynamic libraries and static libraries is the same, because dynamic libraries must also have a small static export library for linking dynamic libraries (Linux can directly link so files, but must be created for dll under Windows A `.a` file is used for the link). We still use the previous number library as an example to illustrate how to use it in a dynamic library.

For the gcc environment under macOS and Linux, we can create a dynamic library of the number library with the following command:

```
$ cd number
$ gcc -shared -o libnumber.so number.c
```

Because the base names of dynamic libraries and static libraries are libnumber, only the suffix names are different. So the code for the Go language part is exactly the same as the static library version:

```go
Package main

//#cgo CFLAGS: -I./number
//#cgo LDFLAGS: -L${SRCDIR}/number -lnumber
//
//#include "number.h"
Import "C"
Import "fmt"

Func main() {
fmt.Println(C.number_add_mod(10, 5, 12))
}
```

GCC will automatically find libnumber.a or libnumber.so for linking at compile time.

For the windows platform, we can also use VC tools to generate dynamic libraries (there are some complex C++ libraries under Windows that can only be built with VC). We need to first create a def file for number.dll that controls the symbols to be exported to the dynamic library.

The contents of the number.def file are as follows:

```
LIBRARY number.dll

EXPORTS
Number_add_mod
```

The first line of LIBRARY indicates the file name of the dynamic library, and then the EXPORTS statement is followed by a list of symbol names to be exported.

Now we can use the following command to create a dynamic library (need to enter the x64 command line environment corresponding to the VC).

```
$ cl /c number.c
$ link /DLL /OUT:number.dll number.obj number.def
```

At this time, an export library of number.lib will be generated for the dll at the same time. But in CGO we can't use the link library in lib format.

The export library to generate the `.a` format needs to be completed by the dlltool command in the mingw toolbox:

```
$ dlltool -dllname number.dll --def number.def --output-lib libnumber.a
```

After the libnumber.a file is generated, it can be linked by the `-lnumber` link parameter.

It should be noted that at runtime, the dynamic library needs to be placed in a location that the system can find. For Windows, you can put the dynamic library and executable program in the same directory, or add the absolute path of the directory where the dynamic library is located to the PATH environment variable. For macOS, you need to set the DYLD_LIBRARY_PATH environment variable. For Linux systems, you need to set the LD_LIBRARY_PATH environment variable.

## 2.9.3 Exporting C Static Library

CGO can not only use C static libraries, but also export functions implemented by Go as C static libraries. We now use Go to implement the modulo addition function of the previous number library.

Create number.go with the following content:

```go
Package main

Import "C"

Func main() {}

//export number_add_mod
Func number_add_mod(a, b, mod C.int) C.int {
Return (a + b) % mod
}
```

According to the requirements of the CGO document, we need to export the C function in the main package. For the C static library construction method, the main function in the main package is ignored, and the C function is simply exported. Construct with the following command:

```
$ go build -buildmode=c-archive -o number.a
```

While generating the number.a static library, cgo also generates a number.h file.

The contents of the number.h file are as follows (for ease of display, the content has been streamlined):

```c
#ifdef __cplusplus
Extern "C" {
#endif

Extern int number_add_mod(int p0, int p1, int p2);

#ifdef __cplusplus
}
#endif
```

The syntax of the `extern "C"` part is to adapt both C and C++ languages. The core content is to declare the number_add_mod function to be exported.

Then we create a C file of `_test_main.c` for testing the generated C static library (underlined as the prefix name is to ignore this file in order to let go build C static library):

```c
#include "number.h"

#include <stdio.h>

Int main() {
Int a = 10;
Int b = 5;
Int c = 12;

Int x = number_add_mod(a, b, c);
Printf("(%d+%d)%%%d = %d\n", a, b, c, x);

Return 0;
}
```

Compile and run with the following command:

```
$ gcc -o a.out _test_main.c number.a
$ ./a.out
```

The process of creating a static library using CGO is very simple.

## 2.9.4 Export C Dynamic Library

The process of exporting dynamic libraries by CGO is similar to that of static libraries, except that the build mode is changed to `c-shared` and the output file name is changed to `number.so`.

```
$ go build -buildmode=c-shared -o number.so
```

The contents of the `_test_main.c` file are unchanged, then compile and run with the following command:

```
$ gcc -o a.out _test_main.c number.so
$ ./a.out
```

## 2.9.5 Exporting functions that are not main packages

By `go help buildmode` command can view the build description of the C static library and the C dynamic library:

```
-buildmode=c-archive
Build the listed main package, plus all packages it imports,
Into a C archive file. The only callable symbols will be those
Functions exported using a cgo //export comment. Requires
Exactly one main package to be listed.

-buildmode=c-shared
Build the listed main package, plus all packages it imports,
Into a C shared library. The only callable symbols will
Be those functions exported using a cgo //export comment.
Requires exactly one main package to be listed.
```

The documentation states that the exported C function must be exported in the main package before the generated header file contains the declared statement. But many times we may prefer to organize different types of export functions into different Go packages and then export them as a static library or a dynamic library.

To implement a C function from a non-main package, or to export a C function from multiple packages (because there can only be one main package), we need to provide the header file corresponding to the exported C function (because CGO cannot be a non-main package) Export the function to generate the header file).

Suppose we first create a number subpackage that provides a modular addition function:

```go
Package number

Import "C"

//export number_add_mod
Func number_add_mod(a, b, mod C.int) C.int {
Return (a + b) % mod
}
```

Then the current main package:

```go
Package main

Import "C"

Import (
"fmt"

_ "./number"
)

Func main() {
Println("Done")
}

//export goPrintln
Func goPrintln(s *C.char) {
fmt.Println("goPrintln:", C.GoString(s))
}
```

Among them, we import the number sub-package, there is the exported C function number_add_mod in the number sub-package, and we also export the goPrintln function in the main package.

Create a C static library with the following command:

```
$ go build -buildmode=c-archive -o main.a
```

At this time, while generating the main.a static library, a main.h header file is also generated. However, the main.h header file only has the declaration of the goPrintln function exported from the main package, and there is no declaration of the number subpackage export function. In fact, the number_add_mod function exists in the generated C static library, we can use it directly.

Create the `_test_main.c` test file as follows:

```c
#include <stdio.h>

Void goPrintln(char*);
Int number_add_mod(int a, int b, int mod);

Int main() {
Int a = 10;
Int b = 5;
Int c = 12;

Int x = number_add_mod(a, b, c);
Printf("(%d+%d)%%%d = %d\n", a, b, c, x);

goPrintln("done");
Return 0;
}
```

We did not include the main.h header file automatically generated by CGO, but manually declared the two export functions goPrintln and number_add_mod. This way we have implemented the export of C functions from multiple Go packages.