# 2.10 Compiling and linking parameters

Compiling and linking parameters is a constant problem every C/C++ programmer needs to face. Building each C/C++ application requires two steps of compiling and linking, as is CGO.
In this section we will briefly discuss the use of compile and link parameters that are often used in CGO.

## 2.10.1 Compilation parameters: CFLAGS/CPPFLAGS/CXXFLAGS

The compilation parameters are mainly the retrieval path of the header file, predefined macros and other parameters. In theory, C and C++ are completely independent programming languages, and they can have their own independent compilation parameters.
But because the C++ language is deeply compatible with the C language, C++ can even be understood as a superset of the C language, so C and C++ will share a lot of compilation parameters.
Therefore, CGO provides three parameters CFLAGS/CPPFLAGS/CXXFLAGS, where CFLAGS corresponds to C language compilation parameters (with the `.c` suffix name),
CPPFLAGS corresponds to C/C++ code compilation parameters (*.c, *.cc, *.cpp, *.cxx), and CXXFLAGS corresponds to pure C++ compiler parameters (*.cc, *.cpp, *.cxx).

## 2.10.2 Link Parameters: LDFLAGS

The link parameters mainly contain the search directory of the library to be linked and the name of the library to be linked. Because of historical legacy issues, the link library does not support relative paths, we must specify an absolute path for the link library.
${SRCDIR} in cgo is the absolute path to the current directory. The compiled C and C++ object file formats are the same, so LDFLAGS corresponds to the C/C++ common link parameters.

## 2.10.3 pkg-config

Providing compile and link parameters for different C/C++ libraries is a very tedious task, so cgo provides support for the `pkg-config` tool.
We can use the `#cgo pkg-config xxx` command to generate the compilation and link parameters needed by the xxx library.
`pkg-config xxx --cflags` generates the build parameters and generates the link parameters via the `pkg-config xxx --libs` command.
It should be noted that the compile and link parameters generated by the `pkg-config` tool are common to C/C++ and cannot be fine-grained.

The `pkg-config` tool is convenient, but there are a lot of non-standard C/C++ libraries that don't support it.
At this time we can manually create the corresponding library compilation and link parameter implementation support for the `pkg-config` tool.

For example, if you have a C/C++ library called xxx, we can manually create the `/usr/local/lib/pkgconfig/xxx.bc` file:

```
Name: xxx
Cflags: -I/usr/local/include
Libs: -L/usr/local/lib â€“lxxx2
```

Where Name is the name of the library, and Cflags and Libs lines correspond to the compilation and link parameters required by the xxx library. If the bc file is in another directory,
The search directory for the `pkg-config` tool can be specified via the PKG_CONFIG_PATH environment variable.

For cgo, we can even specify a custom pkg-config program via the PKG_CONFIG environment variable.
If you implement the CGO-specific pkg-config program yourself, just handle the two parameters `--cflags` and `--libs`.

The following program is the build and link parameters for generating Python3 under the macos system:

```go
// py3-config.go
Func main() {
For _, s := range os.Args {
If s == "--cflags" {
Out, _ := exec.Command("python3-config", "--cflags").CombinedOutput()
Out = bytes.Replace(out, []byte("-arch"), []byte{}, -1)
Out = bytes.Replace(out, []byte("i386"), []byte{}, -1)
Out = bytes.Replace(out, []byte("x86_64"), []byte{}, -1)
fmt.Print(string(out))
Return
}
If s == "--libs" {
Out, _ := exec.Command("python3-config", "--ldflags").CombinedOutput()
fmt.Print(string(out))
Return
}
}
}
```

Then build and use the custom `pkg-config` tool with the following command:

```
$ go build -o py3-config py3-config.go
$ PKG_CONFIG=./py3-config go build -buildmode=c-shared -o gopkg.so main.go
```

Specific details can be found in the Go implementation of the Python module chapter.

## 2.10.4 go get chain

When you use `go get` to get the Go language package, you will get the package dependencies. For example, the A package depends on the B package, the B package depends on the C package, and the C package depends on the D package:
`pkgA -> pkgB -> pkgC -> pkgD -> ...`. After go get get A package, it will get BCD package in turn.
If the build fails after getting the B package, it will lead to the break of the chain, resulting in the failure of the construction of the A package.

There are many reasons for chain breakage, and the common reasons are:

- Some systems are not supported, compilation fails
- Depends on cgo, user does not have gcc installed
- Depends on cgo, but the dependent library is not installed
- Depends on pkg-config, not installed on windows
- Depends on pkg-config, no corresponding bc file found
- Depends on custom pkg-config, requires additional configuration
- Depends on swig, the user does not have swig installed, or the version is wrong

A careful analysis reveals that the problems associated with CGO account for the vast majority of failures. This is not an accidental phenomenon.
Automating the construction of C/C++ code has always been a world problem, and there has not been a unified C/C++ management tool that has been recognized by the current position.

Because the use of cgo, such as gcc and other build tools must be installed, and try to support the mainstream system.
If the dependent C/C++ package is small and source code is available, it can be preferred to build from code.

For example, the `github.com/chai2010/webp` package implements zero configuration dependencies by creating key files for each C/C++ source file in the current package:

```
// z_libwebp_src_dec_alpha.c
#include "./internal/libwebp/src/dec/alpha.c"
```

Therefore, when compiling the `z_libwebp_src_dec_alpha.c` file, the libweb native code will be compiled.
The dependencies are relative directories, and maximum consistency can be maintained for different platform support.

## 2.10.5 Exporting C functions in multiple non-main packages

The official documentation states that the exported Go function should have the main package, but the real thing is that the Go export function of other packages is also valid.
Because the exported Go function can be used as a C function, it must be valid. But the Go functions exported by different packages will be in the same global namespace, so you need to be careful to avoid duplicate names.
If you export Go functions from different packages to C language space, the `_cgo_export.h` file automatically generated by cgo will not contain all the function declarations everywhere.
We have to export all the functions by way of a handwritten header file.