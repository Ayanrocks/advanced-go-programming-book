# 4.4 Getting started with gRPC

gRPC is a cross-language open source RPC framework developed by Google based on Protobuf. Designed based on the HTTP/2 protocol, gRPC can provide multiple services based on an HTTP/2 link, making it more mobile-friendly. This section will cover the simple use of gRPC.

## 4.4.1 gRPC Technology Stack

The gRPC technology stack of the Go language is shown in Figure 4-1:

![](../images/ch4-1-grpc-go-stack.png)

*Figure 4-1 gRPC Technology Stack*

The bottom layer is the TCP or Unix Socket protocol. On top of this is the implementation of the HTTP/2 protocol. Then, on the HTTP/2 protocol, the gRPC core library for the Go language is built. The Stub code generated by the application through the gRPC plug-in communicates with the gRPC core library, and can also communicate directly with the gRPC core library.

## 4.4.2 Getting started with gRPC

From the perspective of Protobuf, gRPC is nothing more than a generator that generates code for the service interface. We implemented a simple Protobuf code generator plugin manually in the second section of this chapter, except that the code generated at the time was adapted to the RPC framework of the standard library. Now we will learn the usage of gRPC.

Create a hello.proto file and define the HelloService interface:

```proto
Syntax = "proto3";

Package main;

Message String {
String value = 1;
}

Service HelloService {
Rpc Hello (String) returns (String);
}
```

Generate gRPC code using the built-in gRPC plugin from protoc-gen-go:

```
$ protoc --go_out=plugins=grpc:. hello.proto
```

The gRPC plugin generates different interfaces for the server and client:

```go
Type HelloServiceServer interface {
Hello(context.Context, *String) (*String, error)
}

Type HelloServiceClient interface {
Hello(context.Context, *String, ...grpc.CallOption) (*String, error)
}
```

gRPC provides context support for each method call via the context.Context parameter. When the client invokes the method, it can provide additional context information through optional parameters of type grpc.CallOption.

The HelloServiceServer interface based on the server can reimplement the HelloService service:

```go
Type HelloServiceImpl struct{}

Func (p *HelloServiceImpl) Hello(
Ctx context.Context, args *String,
) (*String, error) {
Reply := &String{Value: "hello:" + args.GetValue()}
Return reply, nil
}
```

The startup process of the gRPC service is similar to the RPC service startup process of the standard library:

```go
Func main() {
grpcServer := grpc.NewServer()
RegisterHelloServiceServer(grpcServer, new(HelloServiceImpl))

Lis, err := net.Listen("tcp", ":1234")
If err != nil {
log.Fatal(err)
}
grpcServer.Serve(lis)
}
```

The first is to construct a gRPC service object through `grpc.NewServer()`, and then register our implementation of the HelloServiceImpl service through the RegisterHelloServiceServer function generated by the gRPC plugin. Then provide the gRPC service on a listening port via `grpcServer.Serve(lis)`.

Then you can link to the gRPC service through the client:

```go
Func main() {
Conn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())
If err != nil {
log.Fatal(err)
}
Defer conn.Close()

Client := NewHelloServiceClient(conn)
Reply, err := client.Hello(context.Background(), &String{Value: "hello"})
If err != nil {
log.Fatal(err)
}
fmt.Println(reply.GetValue())
}
```

Where grpc.Dial is responsible for establishing a link with the gRPC service, and then the NewHelloServiceClient function constructs a HelloServiceClient object based on the established link. The returned client is actually a HelloServiceClient interface object. The method defined by the interface can call the method provided by the gRPC service corresponding to the server.

There is a difference between the gRPC and the RPC framework of the standard library. The interface generated by gRPC does not support asynchronous calls. However, we can safely share the underlying HTTP/2 link between gRPCs across multiple Goroutines, so we can simulate asynchronous calls by blocking calls in another Goroutine.

## 4.4.3 gRPC flow

RPC is a remote function call, so the function parameters and return values ​​of each call cannot be too large, otherwise the response time of each call will be seriously affected. Therefore, traditional RPC method calls are not suitable for uploading and downloading large data volume scenarios. At the same time, the traditional RPC mode is not applicable to subscription and release modes that are uncertain in time. To this end, the gRPC framework provides flow characteristics for the server and client respectively.

The one-way flow of the server or client is a special case of bidirectional flow. We add a Channel method that supports bidirectional flow in HelloService:

```proto
Service HelloService {
Rpc Hello (String) returns (String);

Rpc Channel (stream String) returns (stream String);
}
```

The keyword stream specifies the stream feature to be enabled, the parameter part is the stream that receives the client parameter, and the return value is the stream that is returned to the client.

Regenerate the code to see the definition of the newly added Channel method in the interface:

```go
Type HelloServiceServer interface {
Hello(context.Context, *String) (*String, error)
Channel(HelloService_ChannelServer) error
}
Type HelloServiceClient interface {
Hello(ctx context.Context, in *String, opts ...grpc.CallOption) (
*String, error,
)
Channel(ctx context.Context, opts ...grpc.CallOption) (
HelloService_ChannelClient, error,
)
}
```

The Channel method parameter on the server side is a new HelloService_ChannelServer type parameter that can be used for two-way communication with the client. The client's Channel method returns a return value of type HelloService_ChannelClient, which can be used for two-way communication with the server.

HelloService_ChannelServer and HelloService_ChannelClient are interface types:

```go
Type HelloService_ChannelServer interface {
Send(*String) error
Recv() (*String, error)
grpc.ServerStream
}

Type HelloService_ChannelClient interface {
Send(*String) error
Recv() (*String, error)
grpc.ClientStream
}
```

It can be found that both the server and client stream auxiliary interfaces define the Send and Recv methods for two-way communication of streaming data.

Now we can implement streaming services:

```go
Func (p *HelloServiceImpl) Channel(stream HelloService_ChannelServer) error {
For {
Args, err := stream.Recv()
If err != nil {
If err == io.EOF {
Return nil
}
Return err
}

Reply := &String{Value: "hello:" + args.GetValue()}

Err = stream.Send(reply)
If err != nil {
Return err
}
}
}
```

The server receives the data sent by the client in the loop. If io.EOF is encountered, the client stream is closed. If the function exits, the server stream is closed. The generated returned data is sent to the client through the stream, and the sending and receiving of the bidirectional stream data is completely independent. It should be noted that the operations of sending and receiving do not need one-to-one correspondence, and the user can organize the code according to the real scene.

The client needs to call the Channel method to get the returned stream object:

```go
Stream, err := client.Channel(context.Background())
If err != nil {
log.Fatal(err)
}
```

On the client side we put the send and receive operations into two separate Goroutines. The first is to send data to the server:

```go
Go func() {
For {
If err := stream.Send(&String{Value: "hi"}); err != nil {
log.Fatal(err)
}
time.Sleep(time.Second)
}
}()
```

Then receive the data returned by the server in the loop:

```go
For {
Reply, err := stream.Recv()
If err != nil {
If err == io.EOF {
Break
}
log.Fatal(err)
}
fmt.Println(reply.GetValue())
}
```

This completes the complete stream reception and delivery support.

## 4.4.4 Publishing and subscription mode

In the previous section, we implemented a simplified version of the Watch method based on Go's built-in RPC library. The Watch-based idea can also construct a publish and subscribe system, but because RPC lacks a streaming mechanism, it can only return one result at a time. In the publish and subscribe mode, the publish behavior initiated by the caller is similar to a normal function call, while the passive subscriber is similar to the receiver in the gRPC client's one-way flow. Now we can try to build a publish and subscribe system based on gRPC's stream characteristics.

Publishing a subscription is a common design pattern, and there are already many implementations of this pattern in the open source community. The docker project provides a minimal implementation of pubsub, the following is a local publish subscription code based on the pubsub package implementation:

```go
Import (
"github.com/moby/moby/pkg/pubsub"
)

Func main() {
p := pubsub.NewPublisher(100*time.Millisecond, 10)

GolaNg := p.SubscribeTopic(func(v interface{}) bool {
If key, ok := v.(string); ok {
If strings.HasPrefix(key, "golang:") {
Return true
}
}
Return false
})
Docker := p.SubscribeTopic(func(v interface{}) bool {
If key, ok := v.(string); ok {
If strings.HasPrefix(key, "docker:") {
Return true
}
}
Return false
})

Go p.Publish("hi")
Go p.Publish("golang: https://golang.org")
Go p.Publish("docker: https://www.docker.com/")
time.Sleep(1)

Go func() {
fmt.Println("golang topic:", <-golang)
}()
Go func() {
fmt.Println("docker topic:", <-docker)
}()

<-make(chan bool)
}
```

Where `pubsub.NewPublisher` constructs a publish object, and `p.SubscribeTopic()` can be used to filter topics of interest for subscription.

Now try to provide a cross-network publishing and subscription system based on the gRPC and pubsub packages. First define a publish subscription service interface through Protobuf:

```protobuf
Service PubsubService {
Rpc Publish (String) returns (String);
Rpc Subscribe (String) returns (stream String);
}
```

Among them, Publish is a normal RPC method, and Subscribe is a one-way streaming service. The gRPC plugin then generates the corresponding interface for the server and client:

```go
Type PubsubServiceServer interface {
Publish(context.Context, *String) (*String, error)
Subscribe(*String, PubsubService_SubscribeServer) error
}
Type PubsubServiceClient interface {
Publish(context.Context, *String, ...grpc.CallOption) (*String, error)
Subscribe(context.Context, *String, ...grpc.CallOption) (
PubsubService_SubscribeClient, error,
)
}

Type PubsubService_SubscribeServer interface {
Send(*String) error
grpc.ServerStream
}
```

Because Subscribe is a one-way flow on the server side, only the Send method is generated in the generated HelloService_SubscribeServer interface.

Then you can implement the publish and subscribe services:

```go
Type PubsubService struct {
Pub *pubsub.Publisher
}

Func NewPubsubService() *PubsubService {
Return &PubsubService{
Pub: pubsub.NewPublisher(100*time.Millisecond, 10),
}
}
```

Then implement the publishing method and subscription method:

```go
Func (p *PubsubService) Publish(
Ctx context.Context, arg *String,
) (*String, error) {
p.pub.Publish(arg.GetValue())
Return &String{}, nil
}

Func (p *PubsubService) Subscribe(
Arg *String, stream PubsubService_SubscribeServer,
Error {
Ch := p.pub.SubscribeTopic(func(v interface{}) bool {
If key, ok := v.(string); ok {
If strings.HasPrefix(key,arg.GetValue()) {
Return true
}
}
Return false
})

For v := range ch {
If err := stream.Send(&String{Value: v.(string)}); err != nil {
Return err
}
}

Return nil
}
```

This will allow you to post information from the client to the server:

```go
Func main() {
Conn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())
If err != nil {
log.Fatal(err)
}
Defer conn.Close()

Client := NewPubsubServiceClient(conn)

_, err = client.Publish(
context.Background(), &String{Value: "golang: hello Go"},
)
If err != nil {
log.Fatal(err)
}
_, err = client.Publish(
context.Background(), &String{Value: "docker: hello Docker"},
)
If err != nil {
log.Fatal(err)
}
}
```

Then you can subscribe to the information on another client:

```go
Func main() {
Conn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())
If err != nil {
log.Fatal(err)
}
Defer conn.Close()

Client := NewPubsubServiceClient(conn)
Stream, err := client.Subscribe(
context.Background(), &String{Value: "golang:"},
)
If err != nil {
log.Fatal(err)
}

For {
Reply, err := stream.Recv()
If err != nil {
If err == io.EOF {
Break
}
log.Fatal(err)
}

fmt.Println(reply.GetValue())
}
}
```

So far we have implemented a cross-network publishing and subscription service based on gRPC.