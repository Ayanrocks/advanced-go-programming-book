# 4.7 pbgo: Protobuf-based framework

Pbgo is a relatively complete mini-frame designed specifically for this section. It is based on Protobuf's extended syntax and automatically generates rpc and rest related code through plugins. In the second section of this chapter we have shown how to customize a Protobuf code generation plugin and generate the code for the rpc part. In this section we will focus on how the rest portion of pbgo related to the Protobuf extension syntax works.

## 4.7.1 Protobuf Extended Syntax

Protobuf's extended syntax is currently used in many open source projects related to Protobuf. The validator mentioned in the previous section is verified by adding extension meta information to the structure members. In the grpc-gateway project, support for the Rest interface is achieved by adding Http-related mapping rules for each method of the service. Pbgo also adds meta information to the rest interface via Protobuf's extended syntax.

The pbgo extension syntax is defined in the `github.com/chai2010/pbgo/pbgo.proto` file:

```protobuf
Syntax = "proto3";
Package pbgo;

Option go_package = "github.com/chai2010/pbgo;pbgo";

Import "google/protobuf/descriptor.proto";

Extend google.protobuf.MethodOptions {
HttpRule rest_api = 20180715;
}

Message HttpRule {
String get = 1;
String put = 2;
String post = 3;
String delete = 4;
String patch = 5;
}
```

The pbgo.proto file is part of the pbgo framework and needs to be imported by other proto files. Protobuf itself has a complete package system, the path of the package here is pbgo. Go language also has its own set of package system, we need to define the mapping relationship between Protobuf and Go language through the extension syntax of go_package. After defining the mapping relationship between the Protobuf and Go languages, other Protobuf files imported into the pbgo.ptoto package will generate the Go language package path of the pbgo.proto mapping when the Go language is generated.

There are five types of Protobuf extension syntax, which are extension information for files, extension information for messages, extension information for message members, extension information for service, and extension information for service methods. Before using extensions, you first need to define the types of extensions and members that can be used for extensions by using the extend keyword. An extended member can be either a base type or a structure type. Pbgo only defines the extension of the service method, only defines an extension member named rest_api, the type is HttpRule structure.

Once the extension is defined, we can use the pbgo extension from other Protobuf files. Create a hello.proto file:

```protobuf
Syntax = "proto3";
Package hello_pb;

Import "github.com/chai2010/pbgo/pbgo.proto";

Message String {
String value = 1;
}

Service HelloService {
Rpc Hello (String) returns (String) {
Option (pbgo.rest_api) = {
Get: "/hello/:value"
};
}
}
```

First we introduce the extension definition by importing the `github.com/chai2010/pbgo/pbgo.proto` file, and then use the extension defined by pbgo in the Hello method of the HelloService. The information extended by the Hello method indicates that the method corresponds to a REST interface, and only one GET method corresponds to the "/hello/:value" path. The syntax of the httprouter routing package is used in the path of the REST method. ":value" indicates that the field in the path corresponds to the member with the same name in the parameter.

## 4.7.2 Reading extended information in the plugin

In the second section of this chapter we have briefly described how the Protobuf plugin works and shows how to generate the necessary code for RPC. The plugin is a generator.Plugin interface:

```go
Type Plugin interface {
// Name identifies the plugin.
Name() string
// Init is called once after data structures are built but before
// code generation begins.
Init(g *Generator)
// Generate produces the code generated by the plugin for this file,
//except for the imports, by calling the generator's methods P, In,
// and Out.
Generate(file *FileDescriptor)
// GenerateImports produces the import declarations for this file.
// It is called after Generate.
GenerateImports(file *FileDescriptor)
}
```

We need to generate the relevant code in the Generate and GenerateImports functions respectively. The entire information of the Protobuf file is described in the *generator.FileDescriptor type function parameter, so we need to extend the defined metadata in advance from the function parameters.

The plugin object in the pbgo framework is pbgoPlugin. In the Generate method, you first need to iterate through all the services defined in the Protobuf file, and then traverse each method of each service. After getting the method structure, extract the rest extension information through the custom getServiceMethodOption method:

```go
Func (p *pbgoPlugin) Generate(file *generator.FileDescriptor) {
For _, svc := range file.Service {
For _, m := range svc.Method {
httpRule := p.getServiceMethodOption(m)
...
}
}
}
```

Before we talk about the getServiceMethodOption method, let's review the definition of the method extension:

```protobuf
Extend google.protobuf.MethodOptions {
HttpRule rest_api = 20180715;
}
```

Pbgo defines an extension of the rest_api name for the service method. The resulting Go code will include a pbgo.E_RestApi global variable, through which the user-defined extension information can be obtained.

The following is the implementation of the getServiceMethodOption method:

```go
Func (p *pbgoPlugin) getServiceMethodOption(
m *descriptor.MethodDescriptorProto,
) *pbgo.HttpRule {
If m.Options != nil && proto.HasExtension(m.Options, pbgo.E_RestApi) {
Ext, _ := proto.GetExtension(m.Options, pbgo.E_RestApi)
If ext != nil {
If x, _ := ext.(*pbgo.HttpRule); x != nil {
Return x
}
}
}
Return nil
}
```

First, determine whether each method defines an extension by using the proto.HasExtension function, and then obtain the user-defined extension information through the proto.GetExtension function. After getting the extension information, we will transform the extension to the pbgo.HttpRule type.

With the extension information, we can generate REST-related code by referring to the way RPC code is generated in Section 2.

## 4.7.3 Generating REST code

The pbgo framework also provides a plugin for generating REST code. However, our goal is to learn the design process of the pbgo framework, so we first try to write the REST code corresponding to the Hello method, and then the plugin automatically generates the code based on the handwritten code construction template.

The HelloService has only one Hello method. The Hello method only defines a REST REST interface:

```protobuf
Message String {
String value = 1;
}

Service HelloService {
Rpc Hello (String) returns (String) {
Option (pbgo.rest_api) = {
Get: "/hello/:value"
};
}
}
```

In order to facilitate the final user, we need to construct a route for the HelloService. So we want to have a function like HelloServiceHandler that can generate a route handler based on the interface of the HelloServiceInterface service:

```go
Type HelloServiceInterface interface {
Hello(in *String, out *String) error
}

Func HelloServiceHandler(svc HelloServiceInterface) http.Handler {
Var router = httprouter.New()
_handle_HelloService_Hello_get(router, svc)
Return router
}
```

The code chooses the popular httprouter routing engine in open source. The _handle_HelloService_Hello_get function is used to register the Hello method to the route handler:

```go
Func _handle_HelloService_Hello_get(
Router *httprouter.Router, svc HelloServiceInterface,
) {
router.Handle("GET", "/hello/:value",
Func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
Var protoReq, protoReply String

Err := pbgo.PopulateFieldFromPath(&protoReq, fieldPath, ps.ByName("value"))
If err != nil {
http.Error(w, err.Error(), http.StatusBadRequest)
Return
}

If err := svc.Hello(&protoReq, &protoReply); err != nil {
http.Error(w, err.Error(), http.StatusInternalServerError)
Return
}

If err := json.NewEncoder(w).Encode(&protoReply); err != nil {
Http.Error(w, err.Error(), http.StatusInternalServerError)
Return
}
},
)
}
```

First register the routing function through the router.Handle method. Inside the routing function, first load the value parameter from the URL by `ps.ByName("value")`, and then set the member corresponding to the value parameter through the pbgo.PopulateFieldFromPath helper function. After the input parameters are ready, you can call the Hello method of the HelloService service, and finally return the result returned by the Hello method with json code.

After manually constructing the structure of the final code, you can construct a template for the plugin generated code on this basis. The complete plugin code and templates are in the `protoc-gen-pbgo/pbgo.go` file, which the reader can refer to.

## 4.7.4 Starting REST Service

Although the process of constructing a pbgo framework from scratch is cumbersome, using pbgo to construct a REST service is extremely simple. First, construct a service object that satisfies the HelloServiceInterface interface:

```go
Import (
"github.com/chai2010/pbgo/examples/hello.pb"
)

Type HelloService struct{}

Func (p *HelloService) Hello(request *hello_pb.String, reply *hello_pb.String) error {
reply.Value = "hello:" + request.GetValue()
Return nil
}
```

As with the RPC code, simply return the result in the Hello method. Then call the HelloServiceHandler function corresponding to the service to generate the route processor and start the service:

```go
Func main() {
Router := hello_pb.HelloServiceHandler(new(HelloService))
log.Fatal(http.ListenAndServe(":8080", router))
}
```

Then test the REST service on the command line:

```
$ curl localhost:8080/hello/vgo
```

Such a super simple pbgo framework is complete!